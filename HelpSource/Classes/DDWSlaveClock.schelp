TITLE:: DDWSlaveClock
summary:: A slave clock for SuperCollider instances to be synchronized across a network
categories:: Scheduling
related:: Classes/DDWMasterClock, Classes/TempoClock

DESCRIPTION::

With link::Classes/DDWMasterClock::, a minimalistic master-slave approach to synchronizing multiple SuperCollider language instances over a local network. (Technical details below: link::Classes/DDWSlaveClock#How it works::.)

The local network should allow broadcast messages (IP address code::"255.255.255.255"::). If your system has a firewall, make sure SuperCollider's ports (57120, 57110) are open for UDP traffic.

Both DDWSlaveClock and link::Classes/DDWMasterClock:: inherit from TempoClock. After creating the clocks, their operation is identical to that of TempoClock. Basic TempoClock features are not documented here; consult the link::Classes/TempoClock:: help file for details.

NOTE:: For obvious reasons, you should not try to change a slave clock's tempo or beats. By design, these are synchronized to the master. ::

Subsection:: Usage

Normal usage is:

list::
## One master clock, providing a global tempo for the entire network.
## Any number of slave clocks, on other machines.
::

For this use case, the procedure is: 1. Create the master clock. 2. On the other machines, create one slave clock instance per machine. The slaves should automatically detect sync messages coming from the master, and synchronize beats and tempo within a second or two.

It is also possible to run multiple master clocks, at different tempi. Each master clock should have a different ID. (If you don't provide one, an ID will be chosen from link::Classes/UniqueID::, but if you need multiple tempi, it is highly recommended to specify an ID as a number or link::Classes/Symbol::.) Then, slave clocks can be created for specific IDs. (Note: This scenario is not extensively tested yet.)

CLASSMETHODS::

METHOD:: new
Create a slave clock instance.

ARGUMENT:: tempo
Retained for interface compatibility with TempoClock. Once this clock syncs to a master, any tempo you provide here will be ignored.

ARGUMENT:: beats
Retained for interface compatibility with TempoClock.

ARGUMENT:: seconds
Retained for interface compatibility with TempoClock.

ARGUMENT:: queueSize
As in TempoClock, the size of the scheduler array.

ARGUMENT:: id
The ID of the master clock to which to synchronize. Optional: If you don't provide one, this clock will respond to the first sync message it receives, and use the ID in that message.

returns:: The new clock instance.


INSTANCEMETHODS::

METHOD:: id
The clock's ID.

METHOD:: latency
The latency value in the sync messages coming from the master.

returns:: A numeric latency value.

METHOD:: diff
Accounts for the difference between the master machine's system clock and the local machine's clock. (You cannot assume code::SystemClock.seconds:: will be the same across multiple machines.) Accessible for debugging purposes only; this information is not useful for scheduling.

returns:: A number.

METHOD:: netDelay
An estimate of the time it takes for the sync messages to travel from the master to the local machine. Accessible for debugging purposes only; this information is not useful for scheduling.

returns:: A number.

METHOD:: addr
The link::Classes/NetAddr:: from which sync messages are coming. You cannot change this.

returns:: A NetAddr.

subsection:: Statistics methods (normally not used)

METHOD:: clockDriftFactor

A float, representing the expected rate of drift between the local machine's system clock and the remote master's system clock. Formally, this is the "process noise variance" in a one-dimensional Kalman filter -- as variance is the average deviation from the mean squared, and we expect fractional values well below 1.0, the squared difference should be lower than the actual drift rate. Normally, you should not need to change this. If you find sync is unacceptable, you might get better results by adjusting it.

METHOD:: measurementError

A float, representing the expected variance in network message transmission times. Normally, you should not need to change this. If you find sync is unacceptable, you might get better results by adjusting it.

METHOD:: debug

A Boolean. If true, messages will be printed in the post window, providing statistics about clock difference and network latency measurement. Normally, you should leave it at the default (false).

METHOD:: debugInstability

Either 0, or a Function returning random positive numbers to be added to network measurements. In production, do not use this! There will be enough network jitter as it is. This method is intended only for testing sync between two sclang processes on the same machine.


PRIVATE:: makeResponder, prSync, stop, prTempo, prBeats, beats, beatsPerBar, tempo, startAliveThread, stopAliveThread



EXAMPLES::

You can run all of this example on one machine in one sclang instance, or run the sections on different machines as indicated.

code::
// ****
// On the master machine:
t = DDWMasterClock(2);

(
p = Pbind(
	\degree, Pwhite(0, 5, inf) - 7,
	\dur, 1
).play(t, quant: -1);
)

p.stop;  // when finished
t.stop;  // this "releases" the slave to run on its own time


// ****
// On the slave machine (also works on the master machine)
u = DDWSlaveClock.new;

(
q = Pbind(
	\degree, Pwhite(0, 5, inf),
	\dur, 0.5
).play(u, quant: -1);
)

q.stop;  // when finished
u.stop;
::

Subsection:: Acknowledgment

Credit is due to Scott Wilson, for one critical idea borrowed from his BeaconClock class (in the Utopia quark). A possible issue with clock sync is processor contention: integer beats tend to be busy. BeaconClock and DDWMasterClock both broadcast sync messages at randomized intervals, so that sync messages will almost certainly be sent "in between" musical events, avoiding messaging delays.

Subsection:: How it works

You don't need to know this in order to use the classes. But, it's interesting, and also worth explaining to somebody who might want to modify the classes in the future.

The master clock runs as a normal TempoClock. At random intervals (random, to avoid handling sync at metrically important time points when the language is likely to be busy), the master sends a timestamped OSC bundle containing the clock's ID, current beats, latency and tempo. Timestamps are calculated based on the system time. We assume that both the DDWMasterClock's beat counter and the system time (and therefore, the OSC timestamps) increment in a stable fashion.

Slave clocks receive these bundles, and schedule an action to match the incoming timestamp. The action updates 'this' DDWSlaveClock's tempo and beat counter (see link::Classes/TempoClock#-beats::). Sclang receives the bundle immediately; the timestamp reflects the future time when the update should happen, irrespective of network jitter (in the same way that scsynth schedules timestamped bundles for reliable timing). The timestamps are not subject to jitter, so, scheduling the clock update according to the timestamp is also not subject to jitter.

The problem: The slave's system time is probably different from the master's. The timestamp received in link::Classes/OSCFunc:: is correct on the master machine, but not on the slave, but the difference between the two should be constant. If we can measure the difference, then it is easy to convert the timestamp into the local code::SystemClock.seconds::. But the slave sclang emphasis::does not know when (in its own timebase) the message was sent::, only when the message was received. Receipt time emphasis::is:: subject to jitter. There is always "measurement error," which may be severe (I observed up to +130 ms inconsistency).

To address this, I use a one-dimensional Kalman filter, assuming a stable value (the difference between two clocks' times in seconds should be constant) with a large measurement error. In practice, the clocks may drift slightly, but we can assume that any drift will be relatively slow ("process noise" in Kalman filter terms). Apart from this drift, one second on one machine should be one second on the other, so, if there is no network timing jitter, code::SystemClock.seconds - timestamp:: will be constant (or extremely slowly changing).

At the same time, the slave periodically sends "ping" messages to the master, to estimate the one-way network latency (another Kalman filter). We assume network latency is some kind of random distribution, always positive, that applies consistently to all messages. Therefore, the difference between clock times will be biased slightly more positive than it should be, by an amount roughly equal to the network delay estimated by pinging. So, the sync method subtracts the one-way network delay.

So we have 1/ stable timestamps and 2/ a relationship between remote and local time that is stabilized by Kalman filters. I have tested up to +150 ms random timing offsets and found that the slave clock performs acceptably for musical content. If network jitter can be reduced, it can perform even better.
